## Documentation:

Sorry in advance for the poor documentation. I waited too long to do it, and I forgot some stuff. Nevertheless, some of the things in here should be enough to at least start you in the write direction or sport a correct answer.

Also note that this is technically in markdown, but I have not been careful about making sure it displays well or that special characters render properly. If necessary, just look at the plaintext source, which should be readable.


#### Setting up the board

Follow the documentation here to set up the board, the networking, etc:
https://github.com/night1rider/Xilinx-KR260-Intro/blob/Hello-World/Documentation/00_hello_world_kr260.md

It is very possible you will encounter issues, but that is beyond the scope of this documentation. I personally had networking issues, but the variety of possible issues is too hard to describe here.

#### Getting the Ubuntu rootfs

The best way to get an Ubuntu rootfs so you don't have to learn petalinux, can grab packages, etc is with debootstrap. I don't recall exactly how to do this truthfully, and it's actually kind of complicated (stage 2 involves chroot, you use qemu, etc.)*.


#### Getting internet on the board

To get internet on your board, use ip forwarding. This involves some iptables commands on your VM. Here are the rough instructions with enp0s3 as the ethernet name on the VM and outgoing is enp0s8. Note that I could have these mixed up, but I think I'm right. Note also that this doesn't mean that enp0s8 is listed on the device -- both enp0s3 and enp0s8 are listed when doing ip addr show on your VM, but enp0s3 is associated with inet: 192.168.2.10/24.
sudo sysctl -w net.ipv4.ip_forward=1
sudo iptables -t nat -A POSTROUTING -o enp0s8 -j MASQUERADE
sudo iptables -A FORWARD -i enp0s3 -o enp0s8 192.168.2.0/24 -j ACCEPT
sudo iptables -A FORWARD -i enp0s8 -o enp0s3 -m state --state RELATED,ESTABLISHED -j ACCEPT

These commands should roughly do the trick. Note that for the second to last command, the ip address 192.168.2.10/24 might actually be correct, so try that if this doesn't work. Install iptables-persistent to make this persistent, or write it to /etc/iptables/rules.v4 in this fashion: sudo iptables-save > /etc/iptables/rules.v4
My rules.v4 looked like this when all was said and done:
    \# Generated by iptables-save v1.8.7 on Wed Jul 16 13:57:52 2025
    *filter
    :INPUT ACCEPT [0:0]
    :FORWARD ACCEPT [0:0]
    :OUTPUT ACCEPT [0:0]
    -A FORWARD -s 192.168.2.10/24 -i enp0s3 -o enp0s8 -j ACCEPT
    -A FORWARD -i enp0s8 -o enp0s3 -m state --state RELATED,ESTABLISHED -j ACCEPT
    COMMIT
    \# Completed on Wed Jul 16 13:57:52 2025
    \# Generated by iptables-save v1.8.7 on Wed Jul 16 13:57:52 2025
    *nat
    :PREROUTING ACCEPT [0:0]
    :INPUT ACCEPT [0:0]
    :OUTPUT ACCEPT [0:0]
    :POSTROUTING ACCEPT [0:0]
    -A POSTROUTING -o enp0s8 -j MASQUERADE
    COMMIT
    \# Completed on Wed Jul 16 13:57:52 2025

#### SSHing from the host machine

With the ubuntu rootfs installed, I was no longer able to connect through SSH anymore from the host machine until I ran these commands on my host machine:
sudo ip addr add 192.168.2.1/24 dev enp44s0
sudo ip link set enp44s0 up

Then I could connect with nash@192.168.2.20. Note this is not persistent across reboots -- I recommend adding it to some script that you run everytime you want to connect after a fresh reboot (in this script I also disabled kvm so I could connect to the VM, opened minicom, etc.). ip route or route -n should show you some results related to this (?) (or perhaps results related to the iptables commands). I am relatively confident that there is no need to take action on the device or VM side to make this work, but I could be wrong. If you are not immediately able to ssh from host to device, then running ip addr show on the device and host and showing the results to an llm will likely let it give you a correct result to solve the problem if my instructions do not do it for you.
I believe but would not swear that 192.168.2.1/24 can be any static ip address. enp44s0 should be the name of the ethernet connection when running ip addr show on the host machine.


#### Getting Kernel Headers

To get kernel headers, edit the project-spec/meta-user/conf/user-rootfsconfig file.
Add this line:
CONFIG_kernel-devsrc

Now run petalinux-config -c rootfs and under User Packages, enable kernel-devsrc.

For more info on this process and errors you may encounter, see the top response at this link (the one that starts with BEST SOLUTION): https://adaptivesupport.amd.com/s/question/0D52E00006iHv9GSAS/how-to-build-kernel-headers-with-petalinux?language=en_US 

Now after petalinux-build, inside of <project>/images/linux/rootfs.tar.gz, your kernel headers will exist. Mine personally were at lib/modules/6.6.10-xilinx-v2024.1-g3af4295e00ef/build within there. It could also be in /usr/src/kernel or inside of lib/modules/6.6.10-xilinx-v2024.1-g3af4295e00ef/source Extract with

mkdir -p ~/temp
cd ~/temp

tar -xvzf /opt/Xilinx/Projects/KV260_Base_PetaLinux/images/linux/rootfs.tar.gz \
  ./lib/modules/6.6.10-xilinx-v2024.1-g3af4295e00ef/build

Move to /usr/src inside of your ubuntu rootfs:
sudo mv ./lib/modules/6.6.10-xilinx-v2024.1-g3af4295e00ef/build /usr/src/linux-headers-6.6.10-xilinx

(file path will be different with an nfs, may want to use scp, etc.)

Now you compile a module like this:

obj-m += my_block_driver.o

all:
	make -C /usr/src/linux-headers-6.6.10-xilinx M=$(PWD) modules

clean:
	make -C /usr/src/linux-headers-6.6.10-xilinx M=$(PWD) clean

#### Misc:

It may be useful to know that your kernel source code is inside of <project>/build/tmp/work-shared/<board-name>/kernel-source


#### Modifying the Device Tree:

https://docs.amd.com/r/en-US/ug1144-petalinux-tools-reference-guide/Configuring-Device-Tree

As specified here, add the nodes you want to <project>/project-spec/meta-user/recipes-bsp/device-tree/files/system-user.dsti
Then run petalinux-build. Your stuff should end up inside of <project>/images/linux/system.dtb

Note that if you set up the servers properly according to the documentation from before, the new system.dtb should be correctly placed to take effect when you boot your board. Reboot and do ls /proc/device-tree to see the new driver entries and make sure it is working properly

You can also decompile the system.dtb and check that your new entries are there to make sure everything worked properly:
dtc -I dtb -O dts -o ~/temp/out.dts images/linux/system.dtb
cat ~/temp/out.dts | grep "<name of driver>"


#### Getting compile_commands.json for doing module development:

Odds are you'll want a compile_commands.json file so you can use an LSP while doing module development. This is a bit trickier than usual because of the fact that we used petalinux to build our kernel. In fact I was kinda tweaking out about it, as an aside. However as with the previous things, petalinux makes it easy if (and only if) you know what you're doing. 

Step 1: Install bear on your VM. 
Remark: you may need bear 2.4.4 version specifically. In that case, follow the directions here for switching. There is other useful info in this link too: https://github.com/kstrize/embedded_ide?tab=readme-ov-file#bear-tool
Step 2: run petalinux-devtool modify virtual/kernel
This gave me an output that ended like this: INFO: Recipe linux-xlnx now set up to build from /opt/Xilinx/Projects/KV260_Base_PetaLinux/components/yocto/workspace/sources/linux-xlnx
Remark: Replace this last name with the name of the recipe you want to modify, but odds are it is virtual/kernel (it was for me)
Step 3: Go into that created directory and do something along the lines of 
petalinux-devtool build linux-xlnx -c
bear petalinux-devtool build linux-xlnx
If you're lucky you should have a compile_commands.json file that looks right. Now copy that directory somewhere it can be useful (or move the compile_commands.json file and have it point to the directory)
Note: Run petalinux-devtool reset linux-xlnx when you're done because otherwise it screws up petalinux-build (petalinux bug?). It should keep the directory and compile commands intact though.
Remark: The paths inside of the compile_commands.json only work inside of the VM. One possible solution to this is to develop on the VM with a symlink to the compile_commands.json file from your project directory. Then because the file is shared across the NFS, you can deploy it from the board.


Remark: petalinux reminds me a bit of using nixos except I actually like it better. But similar documentation situation.





---------------------
### AI instructions for Debootstrap

* Link to AI discussion: https://grok.com/share/bGVnYWN5_f7572eb6-0d1d-450f-9eea-078103de4769
* Here is a transcript of the AI discussion about how to complete stage 2 of debootstrap. Note that this assumes stage 1 is complete, but that should be relatively easy with existing online documentation. Note this may have formatting errors, but should give an idea of the directions.



how to configure a fstab when the root fs lives on a nfs this is for a deb bootstrap

Configuring /etc/fstab for a Debian system where the root filesystem is mounted over NFS (Network File System) in a debootstrap environment requires careful setup, as the root filesystem must be available early in the boot process. Below is a step-by-step guide to configure /etc/fstab for an NFS root filesystem in a Debian bootstrap setup.
Prerequisites

    A working NFS server with the root filesystem exported.
    A Debian system bootstrapped using debootstrap.
    Network connectivity configured in the initramfs to access the NFS server during boot.
    The initramfs must include NFS client support and network configuration (e.g., via initramfs-tools).

Steps to Configure /etc/fstab for NFS Root Filesystem

    Understand the NFS Root Setup
        The root filesystem (/) is mounted over NFS, which means the system depends on the network and NFS server to boot.
        The kernel must be configured to mount the NFS root, typically via boot parameters (e.g., in GRUB or another bootloader).
        The /etc/fstab file will define the root filesystem and any additional mounts.
    Edit /etc/fstab

        Open /etc/fstab in the debootstrapped environment (e.g., after chrooting into the bootstrap directory).

        Add an entry for the NFS root filesystem. The general format for an NFS entry in /etc/fstab is:
        text

server:/path/to/export    /mountpoint    nfs    options    dump    pass

For the root filesystem, the entry will look like this:
fstab
nfs-server:/path/to/rootfs    /    nfs    rw,sync,hard,intr    0    0

    nfs-server: The hostname or IP address of the NFS server.
    /path/to/rootfs: The path on the NFS server where the root filesystem is exported.
    /: The mount point (root filesystem).
    nfs: The filesystem type.
    rw,sync,hard,intr: Common NFS mount options:
        rw: Read/write access.
        sync: Forces synchronous I/O for reliability.
        hard: Retries NFS requests indefinitely if the server is unresponsive (recommended for root filesystem).
        intr: Allows interrupting NFS operations if the server is down.
    0 0: Dump and pass fields (typically 0 for NFS, as filesystem checks are not applicable).

Example:
fstab

    192.168.1.100:/srv/nfs/debian-root    /    nfs    rw,sync,hard,intr    0    0

Add Other Essential Filesystems

    Include other required filesystems in /etc/fstab, such as proc, sys, dev, and tmpfs for /tmp. These are typically needed for a functional system:
    fstab

    proc    /proc    proc    defaults    0    0
    sysfs   /sys     sysfs   defaults    0    0
    devtmpfs /dev    devtmpfs    defaults    0    0
    tmpfs   /tmp     tmpfs   defaults    0    0
    If you have additional NFS mounts or local disks, add them as needed.

Configure the Initramfs

    Since the root filesystem is on NFS, the initramfs must be configured to mount it during boot.
    Ensure initramfs-tools is installed in the debootstrapped environment:
    bash

apt install initramfs-tools
Edit /etc/initramfs-tools/initramfs.conf and set the following:
conf
BOOT=nfs
Configure the network in /etc/initramfs-tools/hooks-scripts or by adding a network configuration script to /etc/initramfs-tools/scripts/init-premount/. For example:
bash
# /etc/initramfs-tools/scripts/init-premount/network
#!/bin/sh
ip addr add 192.168.1.101/24 dev eth0
ip link set eth0 up
ip route add default via 192.168.1.1
Replace 192.168.1.101/24 and 192.168.1.1 with your client IP and gateway.
Update the initramfs:
bash

    update-initramfs -u

Configure Bootloader (e.g., GRUB)

    The kernel needs to know where to find the NFS root. Edit the bootloader configuration (e.g., /etc/default/grub) to include NFS root parameters.
    Add or modify the GRUB_CMDLINE_LINUX line:
    bash

GRUB_CMDLINE_LINUX="root=/dev/nfs nfsroot=192.168.1.100:/srv/nfs/debian-root,vers=4,tcp ip=dhcp"

    root=/dev/nfs: Specifies the root filesystem is on NFS.
    nfsroot=server:/path,vers=4,tcp: Specifies the NFS server, export path, NFS version (e.g., vers=4), and protocol (tcp).
    ip=dhcp: Configures the network via DHCP (or specify a static IP, e.g., ip=192.168.1.101::192.168.1.1:255.255.255.0).

Update GRUB:
bash

    update-grub

Ensure Required Packages

    Install NFS client tools in the debootstrapped environment:
    bash

    apt install nfs-common
    Ensure the kernel supports NFS (most Debian kernels do by default).

Test the Configuration

    Exit the chroot and reboot the system.
    Verify that the system boots correctly and mounts the NFS root filesystem.
    Check the mounts:
    bash

        mount | grep nfs
    Troubleshooting Tips
        NFS Server Unreachable: Ensure the NFS server is running, the export is correct, and the network is accessible.
        Initramfs Issues: If the system fails to boot, check /etc/initramfs-tools/initramfs.conf and regenerate the initramfs.
        Network Issues: Verify the network configuration in the initramfs and bootloader.
        Logs: Check /var/log/syslog or use dmesg for NFS-related errors.

Example /etc/fstab

Here’s a complete example of /etc/fstab for a Debian system with an NFS root:
fstab
# NFS root filesystem
192.168.1.100:/srv/nfs/debian-root    /    nfs    rw,sync,hard,intr    0    0

# Standard filesystems
proc    /proc    proc    defaults    0    0
sysfs   /sys     sysfs   defaults    0    0
devtmpfs /dev    devtmpfs    defaults    0    0
tmpfs   /tmp     tmpfs   defaults    0    0
Notes

    Security: Ensure the NFS export is properly secured (e.g., restrict access to specific IPs in /etc/exports on the NFS server).
    Performance: NFS root filesystems can be slower than local storage. Consider tuning NFS options (e.g., rsize, wsize) for better performance.
    Backup: Regularly back up the NFS server, as the root filesystem is critical for the system.

If you encounter specific issues or need help with a particular step, let me know!
guide to debboostrap for arm64 jammy ubuntu, note I already have a kernel and this rootfs will be on a nfs

Below is a step-by-step guide to creating an arm64 Ubuntu Jammy (22.04) root filesystem using debootstrap, with the root filesystem intended to be served over NFS (Network File System). Since you already have a kernel, this guide focuses on creating the root filesystem, configuring it for NFS, and ensuring compatibility with an arm64 architecture.
Prerequisites

    A host system running Linux (preferably Ubuntu or Debian) with debootstrap installed.
    An NFS server configured to export the root filesystem.
    A working arm64 kernel configured to support NFS root and network booting.
    Network connectivity for the target system to access the NFS server.
    A cross-compilation toolchain or native arm64 environment (if running on an arm64 host).
    Root or sudo privileges on the host system.

Steps to Create an arm64 Ubuntu Jammy Root Filesystem for NFS

    Install Required Tools
        On the host system, install debootstrap and other necessary tools:
        bash

    sudo apt update
    sudo apt install debootstrap qemu-user-static binfmt-support
        qemu-user-static enables running arm64 binaries on a non-arm64 host (if needed).
        binfmt-support allows the host to execute arm64 binaries transparently.

Set Up the Target Directory

    Create a directory to hold the root filesystem:
    bash

    sudo mkdir /path/to/rootfs
    Example: /srv/nfs/ubuntu-jammy-arm64

Run debootstrap for Ubuntu Jammy (arm64)

    Use debootstrap to create an arm64 Ubuntu Jammy root filesystem:
    bash

sudo debootstrap --arch=arm64 jammy /path/to/rootfs http://ports.ubuntu.com/ubuntu-ports/

    --arch=arm64: Specifies the arm64 architecture.
    jammy: The Ubuntu release (22.04).
    /path/to/rootfs: The target directory for the root filesystem.
    http://ports.ubuntu.com/ubuntu-ports/: The Ubuntu mirror for arm64 packages.

If you encounter issues with the mirror, you can try an alternative, such as:
bash

    http://archive.ubuntu.com/ubuntu/

Configure the Root Filesystem

    Chroot into the Root Filesystem:
    bash

sudo chroot /path/to/rootfs
If using a non-arm64 host, ensure qemu-user-static is set up to emulate arm64.
Set Up Sources List: Edit /etc/apt/sources.list to include the necessary repositories:
bash
echo "deb http://ports.ubuntu.com/ubuntu-ports jammy main restricted universe multiverse" > /etc/apt/sources.list
echo "deb http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted universe multiverse" >> /etc/apt/sources.list
echo "deb http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted universe multiverse" >> /etc/apt/sources.list
Update the package index:
bash
apt update
Install Essential Packages: Install packages required for a minimal system and NFS support:
bash

    apt install --no-install-recommends \
        linux-base \
        initramfs-tools \
        nfs-common \
        netbase \
        openssh-server \
        systemd \
        sudo \
        iproute2 \
        iputils-ping

Configure /etc/fstab for NFS Root

    Since the root filesystem will be served over NFS, configure /etc/fstab to mount the root filesystem and other essential filesystems.
    Edit /etc/fstab:
    fstab

    # NFS root filesystem
    nfs-server:/path/to/rootfs    /    nfs    rw,sync,hard,intr    0    0

    # Standard filesystems
    proc    /proc    proc    defaults    0    0
    sysfs   /sys     sysfs   defaults    0    0
    devtmpfs /dev    devtmpfs    defaults    0    0
    tmpfs   /tmp     tmpfs   defaults    0    0
        Replace nfs-server:/path/to/rootfs with your NFS server's IP/hostname and export path (e.g., 192.168.1.100:/srv/nfs/ubuntu-jammy-arm64).
        Options like rw,sync,hard,intr ensure reliable NFS mounting for the root filesystem.

Configure Networking in the Root Filesystem

    Set up networking for the target system. For Ubuntu 22.04, networking is typically managed by systemd-networkd or Netplan.
    Using Netplan: Create a Netplan configuration file, e.g., /etc/netplan/01-netcfg.yaml:
    yaml

network:
  version: 2
  ethernets:
    eth0:
      dhcp4: true
Apply the configuration:
bash
netplan apply
Alternatively, if using a static IP:
yaml

    network:
      version: 2
      ethernets:
        eth0:
          addresses:
            - 192.168.1.101/24
          gateway4: 192.168.1.1
          nameservers:
            addresses: [8.8.8.8, 8.8.4.4]

Configure Initramfs for NFS Boot

    The initramfs must support NFS root booting. Edit /etc/initramfs-tools/initramfs.conf:
    conf

        BOOT=nfs
        Ensure the network is configured in the initramfs. Create a script in `/etc/initramfs-tools/scripts/init-pre

Interrupted
I have to use an x86 machine to do this

Creating an arm64 Ubuntu Jammy (22.04) root filesystem using debootstrap on an x86 host for an NFS-based root filesystem requires cross-architecture support, primarily through qemu-user-static to emulate arm64 binaries. Since you already have an arm64 kernel and the root filesystem will be served over NFS, this guide focuses on setting up the root filesystem on an x86 host, configuring it for NFS, and ensuring it works for your arm64 target system. Below is a detailed step-by-step guide.
Prerequisites

    An x86 Linux host (preferably Ubuntu or Debian) with internet access.
    An NFS server configured to export the root filesystem directory.
    An arm64 kernel configured for NFS root and network booting.
    Root or sudo privileges on the x86 host.
    Network connectivity for the target arm64 system to access the NFS server.

Steps to Create an arm64 Ubuntu Jammy Root Filesystem on an x86 Host

    Install Required Tools on the x86 Host
        Install debootstrap, qemu-user-static, and binfmt-support to enable arm64 binary execution:
        bash

sudo apt update
sudo apt install debootstrap qemu-user-static binfmt-support

    qemu-user-static: Emulates arm64 binaries on the x86 host.
    binfmt-support: Allows the host to transparently execute arm64 binaries.

Verify that qemu-aarch64 is registered:
bash
update-binfmts --display | grep qemu-aarch64
If not registered, enable it:
bash

    sudo update-binfmts --enable qemu-aarch64

Set Up the Target Directory

    Create a directory for the root filesystem, which will be exported via NFS:
    bash

    sudo mkdir /srv/nfs/ubuntu-jammy-arm64
    Adjust the path as needed (e.g., /path/to/rootfs).

Run debootstrap for arm64 Ubuntu Jammy

    Use debootstrap to create the arm64 root filesystem:
    bash

sudo debootstrap --arch=arm64 --foreign jammy /srv/nfs/ubuntu-jammy-arm64 http://ports.ubuntu.com/ubuntu-ports/

    --arch=arm64: Specifies the arm64 architecture.
    --foreign: Performs only the first stage of debootstrap (downloads packages) since the x86 host cannot run arm64 binaries natively.
    jammy: Ubuntu 22.04 release.
    /srv/nfs/ubuntu-jammy-arm64: Target directory for the root filesystem.
    http://ports.ubuntu.com/ubuntu-ports/: arm64 package repository.

If the mirror fails, try an alternative:
bash

    http://archive.ubuntu.com/ubuntu/

Complete the Second Stage of debootstrap

    Copy the qemu-aarch64-static binary to the root filesystem to enable arm64 execution:
    bash

sudo cp /usr/bin/qemu-aarch64-static /srv/nfs/ubuntu-jammy-arm64/usr/bin/
Chroot into the root filesystem and run the second stage of debootstrap:
bash

    sudo chroot /srv/nfs/ubuntu-jammy-arm64
    /debootstrap/debootstrap --second-stage
    This completes the installation of the base system by running arm64-native setup tasks under QEMU emulation.

Configure the Root Filesystem

    While still in the chroot, configure the system:
    bash

export LANG=C
Set Up APT Sources: Edit /etc/apt/sources.list to include Ubuntu Jammy repositories:
bash
echo "deb http://ports.ubuntu.com/ubuntu-ports jammy main restricted universe multiverse" > /etc/apt/sources.list
echo "deb http://ports.ubuntu.com/ubuntu-ports jammy-updates main restricted universe multiverse" >> /etc/apt/sources.list
echo "deb http://ports.ubuntu.com/ubuntu-ports jammy-security main restricted universe multiverse" >> /etc/apt/sources.list
Update the package index:
bash
apt update
Install Essential Packages: Install packages needed for a minimal system and NFS support:
bash

    apt install --no-install-recommends \
        linux-base \
        initramfs-tools \
        nfs-common \
        netbase \
        openssh-server \
        systemd \
        sudo \
        iproute2 \
        iputils-ping

Configure /etc/fstab for NFS Root

    Edit /etc/fstab to define the NFS root filesystem and essential mounts:
    fstab

    # NFS root filesystem
    192.168.1.100:/srv/nfs/ubuntu-jammy-arm64    /    nfs    rw,sync,hard,intr    0    0

    # Standard filesystems
    proc    /proc    proc    defaults    0    0
    sysfs   /sys     sysfs   defaults    0    0
    devtmpfs /dev    devtmpfs    defaults    0    0
    tmpfs   /tmp     tmpfs   defaults    0    0
        Replace 192.168.1.100:/srv/nfs/ubuntu-jammy-arm64 with your NFS server's IP/hostname and export path.
        NFS options:
            rw: Read/write access.
            sync: Synchronous I/O for reliability.
            hard: Retries NFS requests indefinitely (critical for root filesystem).
            intr: Allows interrupting NFS operations if the server is unresponsive.

Configure Networking in the Root Filesystem

    Set up networking for the target arm64 system using Netplan (default in Ubuntu 22.04).
    Create /etc/netplan/01-netcfg.yaml:
    yaml

network:
  version: 2
  ethernets:
    eth0:
      dhcp4: true
Alternatively, for a static IP:
yaml
network:
  version: 2
  ethernets:
    eth0:
      addresses:
        - 192.168.1.101/24
      gateway4: 192.168.1.1
      nameservers:
        addresses: [8.8.8.8, 8.8.4.4]
Apply the configuration:
bash

    netplan apply

Configure Initramfs for NFS Boot

    Edit /etc/initramfs-tools/initramfs.conf to enable NFS booting:
    conf

BOOT=nfs
Configure networking in the initramfs. Create a script in /etc/initramfs-tools/scripts/init-premount/network:
bash
#!/bin/sh
ip addr add 192.168.1.101/24 dev eth0
ip link set eth0 up
ip route add default via 192.168.1.1

    Adjust the IP, subnet, and gateway as needed.
    Make the script executable:
    bash

    chmod +x /etc/initramfs-tools/scripts/init-premount/network

If using DHCP, add to /etc/initramfs-tools/initramfs.conf:
conf
DEVICE=eth0
And ensure udhcpc or another DHCP client is included in the initramfs.
Update the initramfs:
bash

    update-initramfs -u

Set Up the NFS Server

    On the NFS server (which may or may not be the x86 host), export the root filesystem.
    Edit /etc/exports on the NFS server:
    exports

/srv/nfs/ubuntu-jammy-arm64 192.168.1.0/24(rw,sync,no_subtree_check,no_root_squash)

    Replace 192.168.1.0/24 with the appropriate network range.
    no_root_squash is required for the root filesystem to allow the client full access.

Reload the NFS server configuration:
bash

    sudo exportfs -ra

Configure the Bootloader for NFS Root

    Since you have an arm64 kernel, configure the bootloader (e.g., U-Boot or GRUB, depending on your arm64 system) to boot with an NFS root.
    Example kernel boot parameters (for U-Boot or GRUB):
    bash

root=/dev/nfs nfsroot=192.168.1.100:/srv/nfs/ubuntu-jammy-arm64,vers=4,tcp ip=dhcp

    root=/dev/nfs: Specifies an NFS root.
    nfsroot=server:/path,vers=4,tcp: NFS server, path, and protocol.
    ip=dhcp: Use DHCP for networking (or specify a static IP, e.g., ip=192.168.1.101::192.168.1.1:255.255.255.0).

For U-Boot, set the bootargs:
bash

    setenv bootargs 'root=/dev/nfs nfsroot=192.168.1.100:/srv/nfs/ubuntu-jammy-arm64,vers=4,tcp ip=dhcp'
    Ensure the kernel and initramfs are accessible (e.g., via TFTP or local storage).

Exit Chroot and Clean Up

    Exit the chroot:
    bash

exit
Remove the QEMU binary from the root filesystem:
bash

    sudo rm /srv/nfs/ubuntu-jammy-arm64/usr/bin/qemu-aarch64-static

Test the Setup

    Boot the arm64 system with the configured kernel, initramfs, and NFS root parameters.
    Verify the NFS root mounts correctly:
    bash

mount | grep nfs
Check network connectivity:
bash

        ping 8.8.8.8

Troubleshooting

    QEMU Issues: Ensure qemu-aarch64-static is correctly installed and binfmt-support is enabled.
    NFS Errors: Verify the NFS server is running, the export path is correct, and the client IP is allowed in /etc/exports.
    Boot Failure: Check kernel boot parameters and initramfs networking scripts. Use dmesg or /var/log/syslog for logs.
    Package Installation Failures: Ensure the ports.ubuntu.com mirror is accessible and the sources list is correct.

Notes

    Security: Restrict NFS exports to specific IPs and consider using a firewall. Use no_root_squash cautiously.
    Performance: Tune NFS options (e.g., rsize=32768,wsize=32768) for better performance if needed.
    Kernel Compatibility: Ensure your arm64 kernel includes NFS client support (CONFIG_NFS_FS, CONFIG_ROOT_NFS) and network drivers.

If you need help with specific steps, such as bootloader configuration or debugging, let me know!
